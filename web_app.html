<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NLP Visualization Suite</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <style>
      :root {
        --primary-color: #3a6ea5;
        --secondary-color: #f8f9fa;
        --text-color: #333;
        --border-color: #dee2e6;
        --sidebar-width: 250px;
        --header-height: 60px;
        --accent-color: #2a5a8e;
        --success-color: #28a745;
        --warning-color: #ffc107;
        --danger-color: #dc3545;
        --info-color: #17a2b8;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        color: var(--text-color);
        background-color: #f5f7fa;
        overflow-x: hidden;
      }

      /* Layout */
      .app-container {
        display: flex;
        min-height: 100vh;
      }

      .sidebar {
        width: var(--sidebar-width);
        background-color: #2c3e50;
        color: white;
        position: fixed;
        height: 100vh;
        overflow-y: auto;
        transition: all 0.3s;
        z-index: 1000;
      }

      .sidebar-header {
        padding: 20px;
        background-color: #1a2530;
        height: var(--header-height);
        display: flex;
        align-items: center;
      }

      .sidebar-header h3 {
        margin: 0;
        font-weight: 500;
      }

      .sidebar-menu {
        padding: 20px 0;
      }

      .sidebar-menu h5 {
        padding: 10px 20px;
        font-size: 0.9rem;
        text-transform: uppercase;
        color: #99a8b8;
        margin-bottom: 5px;
      }

      .sidebar-menu ul {
        list-style: none;
        padding: 0;
      }

      .sidebar-menu li {
        margin-bottom: 5px;
      }

      .sidebar-menu a {
        display: block;
        padding: 10px 20px;
        color: #ecf0f1;
        text-decoration: none;
        transition: all 0.3s;
        font-size: 0.95rem;
      }

      .sidebar-menu a:hover,
      .sidebar-menu a.active {
        background-color: var(--primary-color);
        color: white;
      }

      .sidebar-menu a i {
        margin-right: 10px;
        width: 20px;
        text-align: center;
      }

      .main-content {
        flex: 1;
        margin-left: var(--sidebar-width);
        padding-top: var(--header-height);
      }

      .main-header {
        background-color: white;
        height: var(--header-height);
        position: fixed;
        top: 0;
        right: 0;
        left: var(--sidebar-width);
        z-index: 999;
        display: flex;
        align-items: center;
        padding: 0 20px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }

      .main-header .tabs {
        display: flex;
        height: 100%;
        margin-left: 10px;
      }

      .main-header .tab {
        padding: 0 20px;
        display: flex;
        align-items: center;
        height: 100%;
        cursor: pointer;
        border-bottom: 3px solid transparent;
        transition: all 0.3s;
        font-weight: 500;
      }

      .main-header .tab:hover {
        background-color: var(--secondary-color);
      }

      .main-header .tab.active {
        border-bottom-color: var(--primary-color);
        color: var(--primary-color);
      }

      .content-area {
        padding: 20px;
      }

      /* Hide all content except active */
      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      /* Common Components */
      .card {
        background: white;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        margin-bottom: 20px;
        overflow: hidden;
        border: 1px solid var(--border-color);
      }

      .card-header {
        padding: 12px 16px;
        background-color: var(--secondary-color);
        border-bottom: 1px solid var(--border-color);
        font-weight: 600;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .card-body {
        padding: 16px;
        position: relative;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
        gap: 20px;
      }

      .form-group {
        display: flex;
        flex-direction: column;
        margin-bottom: 12px;
      }

      label {
        font-weight: 500;
        margin-bottom: 6px;
      }

      select,
      input {
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
      }

      button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        transition: background-color 0.2s;
      }

      button:hover {
        background-color: var(--accent-color);
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 16px;
      }

      .visualization {
        height: 450px;
        width: 100%;
      }

      .loading {
        display: none;
        justify-content: center;
        align-items: center;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.8);
        z-index: 10;
      }

      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top: 4px solid var(--primary-color);
        width: 32px;
        height: 32px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .inner-tabs {
        display: flex;
        border-bottom: 1px solid var(--border-color);
        margin-bottom: 15px;
      }

      .inner-tab {
        padding: 8px 16px;
        cursor: pointer;
        border: 1px solid transparent;
        border-bottom: none;
        margin-bottom: -1px;
      }

      .inner-tab.active {
        background-color: white;
        border-color: var(--border-color);
        border-radius: 4px 4px 0 0;
        font-weight: 500;
      }

      .inner-tab-content {
        display: none;
      }

      .inner-tab-content.active {
        display: block;
      }

      .status-message {
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
      }

      .status-success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      .status-error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }

      .status-info {
        background-color: #cce5ff;
        color: #004085;
        border: 1px solid #b8daff;
      }

      /* Word-in-Context specific styles */
      .example-item {
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        margin-bottom: 8px;
      }

      .example-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        font-weight: 600;
      }

      .example-contexts {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }

      .context {
        padding: 8px;
        background-color: var(--secondary-color);
        border-radius: 4px;
        font-size: 0.9rem;
      }

      .highlight {
        font-weight: bold;
        color: var(--primary-color);
      }

      .similarity-bar {
        display: flex;
        align-items: center;
        margin-top: 8px;
      }

      .bar-label {
        width: 120px;
        font-size: 0.85rem;
      }

      .bar {
        height: 10px;
        background-color: var(--primary-color);
        border-radius: 2px;
      }

      /* Cross-lingual specific styles */
      .word-pair-detail {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 15px;
      }

      .word-card {
        flex: 1;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .english-card {
        background-color: #e8f8ff;
        border-left: 5px solid #3498db;
      }

      .spanish-card {
        background-color: #fff8e8;
        border-left: 5px solid #f39c12;
      }

      .connection-metrics {
        text-align: center;
        padding: 15px;
        background-color: #f0f7fb;
        border-radius: 8px;
        margin: 15px 0;
      }

      .similarity-score {
        font-size: 24px;
        font-weight: bold;
        color: #2c3e50;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 15px;
      }

      .stat-card {
        background: linear-gradient(to bottom right, #ffffff, #f5f9ff);
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        border: 1px solid #e1e8ed;
      }

      .stat-title {
        color: #5a6474;
        font-size: 14px;
        margin-bottom: 5px;
      }

      .stat-value {
        color: #2c3e50;
        font-size: 24px;
        font-weight: bold;
      }

      .welcome-container {
        text-align: center;
        padding: 40px 20px;
      }

      .welcome-container h1 {
        font-size: 2.5rem;
        margin-bottom: 20px;
        color: var(--primary-color);
      }

      .welcome-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 40px;
      }

      .welcome-card {
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        padding: 20px;
        text-align: center;
        transition: transform 0.3s;
      }

      .welcome-card:hover {
        transform: translateY(-5px);
      }

      .welcome-card h3 {
        color: var(--primary-color);
        margin-bottom: 10px;
      }

      .welcome-card p {
        color: #666;
        margin-bottom: 15px;
      }

      .welcome-icon {
        font-size: 40px;
        margin-bottom: 15px;
        color: var(--primary-color);
      }

      @media (max-width: 768px) {
        .sidebar {
          width: 0;
          transform: translateX(-100%);
        }

        .sidebar.active {
          width: var(--sidebar-width);
          transform: translateX(0);
        }

        .main-content {
          margin-left: 0;
        }

        .main-header {
          left: 0;
        }

        .grid {
          grid-template-columns: 1fr;
        }

        .word-pair-detail {
          grid-template-columns: 1fr;
        }
      }

      /* Responsive menu toggle */
      .menu-toggle {
        display: none;
        cursor: pointer;
        margin-right: 15px;
        font-size: 1.5rem;
      }

      @media (max-width: 768px) {
        .menu-toggle {
          display: block;
        }
      }

      /* Placeholder graph styles */
      .placeholder-graph {
        height: 400px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f8f9fa;
        border: 2px dashed #dee2e6;
        border-radius: 6px;
        margin: 20px 0;
      }

      .placeholder-text {
        text-align: center;
        color: #6c757d;
      }

      .placeholder-text i {
        font-size: 48px;
        margin-bottom: 15px;
      }
      /* Add these styles to the existing <style> section in the HTML */

      /* Table styles for outliers */
      .table-container {
        overflow-x: auto;
        margin-bottom: 20px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 15px;
      }

      th,
      td {
        padding: 8px 12px;
        text-align: left;
        border: 1px solid var(--border-color);
      }

      th {
        background-color: var(--secondary-color);
        font-weight: 600;
      }

      tr:nth-child(even) {
        background-color: rgba(0, 0, 0, 0.02);
      }

      tr:hover {
        background-color: rgba(58, 110, 165, 0.05);
      }

      /* Word highlight styles */
      .highlight-word {
        font-weight: bold;
        color: var(--primary-color);
        background-color: rgba(58, 110, 165, 0.1);
        padding: 2px 4px;
        border-radius: 3px;
      }

      /* Additional visualization styles */
      .visualization-container {
        position: relative;
        min-height: 400px;
      }

      .vis-loading {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 5;
      }

      /* Button styles */
      .btn-group {
        display: flex;
        gap: 8px;
        margin-bottom: 15px;
      }

      .btn-sm {
        padding: 4px 8px;
        font-size: 0.85rem;
      }

      .btn-outline {
        background-color: transparent;
        border: 1px solid var(--primary-color);
        color: var(--primary-color);
      }

      .btn-outline:hover {
        background-color: var(--primary-color);
        color: white;
      }
    </style>
    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
    />
  </head>
  <body>
    <div class="app-container">
      <!-- Left Sidebar Navigation -->
      <nav class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <h3>LangViz</h3>
        </div>

        <div class="sidebar-menu">
          <h5>Visualizations</h5>
          <ul>
            <li>
              <a href="#" onclick="activateTab('future')">
                <i class="fas fa-chart-bar"></i> RQ1: Semantic Embeds
              </a>
            </li>
            <li>
              <a href="#" onclick="activateTab('cross-lingual')">
                <i class="fas fa-language"></i> RQ2: Cross-Lingual
              </a>
            </li>
            <li>
              <a href="#" onclick="activateTab('wic')">
                <i class="fas fa-layer-group"></i> RQ3: Bert Layers
              </a>
            </li>
          </ul>

          <h5>Navigation</h5>
          <ul>
            <li>
              <a href="#" class="active" onclick="activateTab('home')">
                <i class="fas fa-home"></i> Home
              </a>
            </li>
            <li>
              <a href="#" onclick="activateTab('upload')">
                <i class="fas fa-upload"></i> Upload Data
              </a>
            </li>
          </ul>
          <!-- <h5>Settings</h5>
          <ul>
            <li>
              <a href="#" onclick="toggleTheme()">
                <i class="fas fa-adjust"></i> Toggle Theme
              </a>
            </li>
          </ul> -->
        </div>
      </nav>

      <!-- Main Content Area -->
      <div class="main-content">
        <!-- Top Header with Tabs -->
        <header class="main-header">
          <div class="menu-toggle" onclick="toggleSidebar()">
            <i class="fas fa-bars"></i>
          </div>

          <div class="tabs">
            <div class="tab" onclick="activateTab('future')" data-tab="future">
              RQ1: Semantic Embedding Evaluation
            </div>

            <div
              class="tab"
              onclick="activateTab('cross-lingual')"
              data-tab="cross-lingual"
            >
              RQ2: Cross-Lingual Analysis
            </div>
            <div class="tab active" onclick="activateTab('wic')" data-tab="wic">
              RQ3: BERT WiC Analysis
            </div>
          </div>
        </header>

        <!-- Content Area -->
        <div class="content-area">
          <!-- Home Page -->
          <div id="home" class="tab-content active">
            <div class="welcome-container">
              <h1>NLP Visualization Suite</h1>
              <p>
                A comprehensive toolkit for visualizing and analyzing language
                models and embeddings
              </p>

              <div class="welcome-grid">
                <div class="welcome-card">
                  <div class="welcome-icon">
                    <i class="fas fa-layer-group"></i>
                  </div>
                  <h3>BERT WiC Analysis</h3>
                  <p>
                    Analyze how well different BERT layers can disambiguate word
                    senses in context
                  </p>
                  <button onclick="activateTab('wic')">Launch Analysis</button>
                </div>

                <div class="welcome-card">
                  <div class="welcome-icon">
                    <i class="fas fa-language"></i>
                  </div>
                  <h3>Cross-Lingual Analysis</h3>
                  <p>
                    Explore how multilingual BERT embeddings align between
                    English and Spanish
                  </p>
                  <button onclick="activateTab('cross-lingual')">
                    Launch Analysis
                  </button>
                </div>

                <div class="welcome-card">
                  <div class="welcome-icon">
                    <i class="fas fa-chart-bar"></i>
                  </div>
                  <h3>Semantic Embedding Evaluation</h3>
                  <p>
                    Additional analysis module for expanded NLP visualization
                    capabilities
                  </p>
                  <button onclick="activateTab('future')">
                    Launch Analysis
                  </button>
                </div>
              </div>

              <div class="card" style="margin-top: 40px">
                <div class="card-header">Getting Started</div>
                <div class="card-body">
                  <ol style="margin-left: 20px">
                    <li>
                      Start by uploading your analysis JSON data using the
                      <strong>Upload Data</strong> section
                    </li>
                    <li>
                      Navigate between different visualization modules using the
                      tabs at the top
                    </li>
                    <li>
                      Use the sidebar for quick navigation between different
                      parts of the application
                    </li>
                    <li>
                      Each visualization module offers specific controls to
                      explore different aspects of your language model
                    </li>
                  </ol>
                </div>
              </div>
            </div>
          </div>

          <!-- Upload Data Page -->
          <div id="upload" class="tab-content">
            <h2>Upload Data</h2>
            <p>Select the type of analysis and upload your JSON data files.</p>

            <div class="card">
              <div class="card-header">BERT WiC Analysis</div>
              <div class="card-body">
                <div class="form-group">
                  <label for="wic-upload">Upload WiC analysis (JSON):</label>
                  <input type="file" id="wic-upload" accept=".json" />
                </div>
                <button onclick="uploadWicData()">Upload</button>
                <div id="wic-upload-status" class="status-message"></div>
              </div>
            </div>

            <div class="card">
              <div class="card-header">Cross-Lingual Analysis</div>
              <div class="card-body">
                <div class="form-group">
                  <label for="cross-lingual-upload">
                    Upload Cross-Lingual analysis (JSON):
                  </label>
                  <input type="file" id="cross-lingual-upload" accept=".json" />
                </div>
                <button onclick="uploadCrossLingualData()">Upload</button>
                <div
                  id="cross-lingual-upload-status"
                  class="status-message"
                ></div>
              </div>
            </div>

            <div class="card">
              <div class="card-header">Semantic Embedding Evaluation</div>
              <div class="card-body">
                <div class="form-group">
                  <label for="future-upload">
                    Upload Semantic Embedding Evaluation (JSON):
                  </label>
                  <input type="file" id="future-upload" accept=".json" />
                </div>
                <button onclick="uploadFutureData()">Upload</button>
                <div id="future-upload-status" class="status-message"></div>
              </div>
            </div>
          </div>

          <!-- BERT WiC Visualization Page -->
          <div id="wic" class="tab-content">
            <h2>BERT Layer Visualization</h2>
            <p>
              Analyzing how different BERT layers handle Word-in-Context
              disambiguation
            </p>

            <div class="grid">
              <div class="card">
                <div class="card-header">Layer Performance</div>
                <div class="card-body" style="position: relative">
                  <div class="controls">
                    <div class="form-group">
                      <label for="wic-metric-select">Metric:</label>
                      <select id="wic-metric-select">
                        <option value="accuracy">Accuracy</option>
                        <option value="precision">Precision</option>
                        <option value="recall">Recall</option>
                        <option value="f1">F1 Score</option>
                      </select>
                    </div>
                    <div class="form-group">
                      <label for="wic-method-select">Method:</label>
                      <select id="wic-method-select">
                        <option value="cosine">Cosine Similarity</option>
                        <option value="lr">Logistic Regression</option>
                      </select>
                    </div>
                  </div>
                  <div id="wic-performance-plot" class="visualization"></div>
                  <div id="wic-performance-loading" class="loading">
                    <div class="spinner"></div>
                  </div>
                </div>
              </div>

              <div class="card">
                <div class="card-header">Word Embedding Analysis</div>
                <div class="card-body" style="position: relative">
                  <div class="controls">
                    <div class="form-group">
                      <label for="wic-layer-select">Layer:</label>
                      <select id="wic-layer-select">
                        <option value="0">Layer 0 (Input)</option>
                      </select>
                    </div>
                    <div class="form-group">
                      <label for="wic-word-select">Target Word:</label>
                      <select id="wic-word-select">
                        <option value="all">All Words</option>
                      </select>
                    </div>
                  </div>
                  <div id="wic-embedding-plot" class="visualization"></div>
                  <div id="wic-embedding-loading" class="loading">
                    <div class="spinner"></div>
                  </div>
                </div>
              </div>
            </div>

            <div class="card">
              <div class="card-header">Layer Comparison</div>
              <div class="card-body">
                <div class="inner-tabs">
                  <div
                    class="inner-tab active"
                    data-tab="wic-improved"
                    onclick="activateInnerTab('wic-improved', 'wic-comparison')"
                  >
                    Improved Examples
                  </div>
                  <div
                    class="inner-tab"
                    data-tab="wic-worsened"
                    onclick="activateInnerTab('wic-worsened', 'wic-comparison')"
                  >
                    Worsened Examples
                  </div>
                </div>
                <div id="wic-comparison">
                  <div id="wic-improved" class="inner-tab-content active">
                    <div id="wic-improved-examples"></div>
                  </div>
                  <div id="wic-worsened" class="inner-tab-content">
                    <div id="wic-worsened-examples"></div>
                  </div>
                </div>
              </div>
            </div>

            <div class="card">
              <div class="card-header">Data Status</div>
              <div class="card-body">
                <div id="wic-status" class="status-message status-info">
                  Please upload WiC analysis JSON data to begin visualization
                </div>
                <button
                  onclick="activateTab('upload')"
                  style="margin-top: 10px"
                >
                  Go to Upload Page
                </button>
              </div>
            </div>
          </div>

          <!-- Cross-Lingual Analysis Page -->
          <div id="cross-lingual" class="tab-content">
            <h2>Multilingual BERT Cross-Lingual Analysis</h2>
            <p>
              Evaluating semantic consistency across languages using shared
              multilingual embeddings
            </p>

            <div class="controls">
              <div class="form-group">
                <label for="cl-pair-select">Select Word Pair:</label>
                <select id="cl-pair-select">
                  <option value="all">All Pairs</option>
                </select>
              </div>

              <div class="form-group">
                <label for="cl-category-select">Filter by Category:</label>
                <select id="cl-category-select">
                  <option value="all">All Categories</option>
                </select>
              </div>
            </div>

            <div class="card">
              <div class="card-header">Overall Statistics</div>
              <div class="card-body">
                <div id="cl-overall-stats"></div>
              </div>
            </div>

            <!-- Main PCA Visualization -->
            <div class="card">
              <div class="card-header">
                PCA Visualization of Word Embeddings
              </div>
              <div class="card-body">
                <div id="cl-pca-scatter-plot" class="visualization"></div>
              </div>
            </div>

            <!-- Selected Pair Detail View -->
            <div id="cl-pair-detail" class="card" style="display: none">
              <div class="card-header">Word Pair Details</div>
              <div class="card-body">
                <div class="word-pair-detail">
                  <div class="word-card english-card">
                    <h3 id="cl-english-word">English Word</h3>
                    <p id="cl-english-context">Context sentence...</p>
                  </div>

                  <div class="word-card spanish-card">
                    <h3 id="cl-spanish-word">Spanish Word</h3>
                    <p id="cl-spanish-context">Context sentence...</p>
                  </div>
                </div>

                <div class="connection-metrics">
                  <h3>Cosine Similarity</h3>
                  <div class="similarity-score" id="cl-similarity-value">
                    0.85
                  </div>
                  <p>Category: <span id="cl-pair-category">Synonym</span></p>
                </div>
              </div>
            </div>

            <!-- <div class="grid">
              <div class="card">
                <div class="card-header">
                  Cross-lingual Word Similarity by Category
                </div>
                <div class="card-body">
                  <div
                    id="cl-category-similarity-chart"
                    class="visualization"
                  ></div>
                </div>
              </div>

              <div class="card">
                <div class="card-header">Word Pair Similarities Heatmap</div>
                <div class="card-body">
                  <div id="cl-similarity-heatmap" class="visualization"></div>
                </div>
              </div>
            </div> -->

            <div class="card">
              <div class="card-header">Word Pairs and Contexts</div>
              <div class="card-body">
                <div id="cl-word-pairs-table"></div>
              </div>
            </div>

            <div class="grid">
              <div class="card">
                <div class="card-header">Category Statistics</div>
                <div class="card-body">
                  <div id="cl-category-stats"></div>
                </div>
              </div>
            </div>

            <div class="card">
              <div class="card-header">Data Status</div>
              <div class="card-body">
                <div
                  id="cross-lingual-status"
                  class="status-message status-info"
                >
                  Please upload Cross-Lingual analysis JSON data to begin
                  visualization
                </div>
                <button
                  onclick="activateTab('upload')"
                  style="margin-top: 10px"
                >
                  Go to Upload Page
                </button>
              </div>
            </div>
          </div>

          <!-- Future Module Page -->
          <!-- Replace the existing Future Module tab content with this code -->
          <div id="future" class="tab-content">
            <h2>BERT Word Sense Analysis</h2>
            <p>
              Analyzing the effectiveness of cosine similarity for
              distinguishing between homonyms and synonyms in BERT embeddings.
            </p>

            <div class="card">
              <div class="card-header">Word Selection</div>
              <div class="card-body">
                <div class="controls">
                  <div class="form-group">
                    <label for="future-word-select">Filter by word:</label>
                    <select
                      id="future-word-select"
                      onchange="filterPCAByWord()"
                    >
                      <option value="all">All Words</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>

            <div class="grid">
              <div class="card">
                <div class="card-header">PCA of Word Embeddings</div>
                <div class="card-body">
                  <div id="pca-scatter-plot" class="visualization"></div>
                </div>
              </div>

              <div class="card">
                <div class="card-header">Summary Statistics</div>
                <div class="card-body">
                  <div id="summary-stats"></div>
                </div>
              </div>
            </div>

            <div class="grid">
              <div class="card">
                <div class="card-header">Cosine Similarity Distribution</div>
                <div class="card-body">
                  <div id="cosine-similarity-plot" class="visualization"></div>
                </div>
              </div>

              <div class="card">
                <div class="card-header">Reliability with Common Words</div>
                <div class="card-body">
                  <div id="error-plot" class="visualization"></div>
                </div>
              </div>
            </div>

            <div class="card">
              <div class="card-header">Outlier Analysis</div>
              <div class="card-body">
                <div id="outliers-table"></div>
              </div>
            </div>

            <div class="card">
              <div class="card-header">Data Status</div>
              <div class="card-body">
                <div id="future-status" class="status-message status-info">
                  Please upload Semantic Embedding Evaluation JSON data to begin
                  visualization
                </div>
                <button
                  onclick="activateTab('upload')"
                  style="margin-top: 10px"
                >
                  Go to Upload Page
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global state to store loaded data
      const appState = {
        wic: {
          data: null,
          loaded: false,
        },
        crossLingual: {
          data: null,
          loaded: false,
        },
        future: {
          data: null,
          loaded: false,
        },
      };

      // Initialize the application
      document.addEventListener("DOMContentLoaded", function () {
        // Set up event listeners
        document
          .getElementById("wic-metric-select")
          .addEventListener("change", updateWicPerformancePlot);
        document
          .getElementById("wic-method-select")
          .addEventListener("change", updateWicPerformancePlot);
        document
          .getElementById("wic-layer-select")
          .addEventListener("change", updateWicEmbeddingPlot);
        document
          .getElementById("wic-word-select")
          .addEventListener("change", updateWicEmbeddingPlot);

        document
          .getElementById("cl-pair-select")
          .addEventListener("change", handleClPairChange);
        document
          .getElementById("cl-category-select")
          .addEventListener("change", handleClCategoryChange);

        // Initialize all tabs
        initInnerTabs();
      });

      // Navigation Functions
      function activateTab(tabId) {
        // Hide all tab contents
        const tabContents = document.querySelectorAll(".tab-content");
        tabContents.forEach((content) => {
          content.classList.remove("active");
        });

        // Show selected tab content
        document.getElementById(tabId).classList.add("active");

        // Update top tabs
        const topTabs = document.querySelectorAll(".main-header .tab");
        topTabs.forEach((tab) => {
          tab.classList.remove("active");
          if (tab.dataset.tab === tabId) {
            tab.classList.add("active");
          }
        });

        // Update sidebar links
        const sidebarLinks = document.querySelectorAll(".sidebar-menu a");
        sidebarLinks.forEach((link) => {
          link.classList.remove("active");
          if (link.getAttribute("onclick").includes(`'${tabId}'`)) {
            link.classList.add("active");
          }
        });
      }

      function activateInnerTab(tabId, tabGroupId) {
        // Get all tabs in this group
        const tabGroup = document.getElementById(tabGroupId);
        const tabs = document.querySelectorAll(
          `[data-tab^="${tabId.split("-")[0]}"]`
        );
        const tabContents = tabGroup.querySelectorAll(".inner-tab-content");

        // Hide all tab contents in this group
        tabContents.forEach((content) => {
          content.classList.remove("active");
        });

        // Show selected tab content
        document.getElementById(tabId).classList.add("active");

        // Update tab status
        tabs.forEach((tab) => {
          tab.classList.remove("active");
          if (tab.dataset.tab === tabId) {
            tab.classList.add("active");
          }
        });
      }

      function initInnerTabs() {
        const tabGroups = document.querySelectorAll(".inner-tabs");
        tabGroups.forEach((group) => {
          const tabs = group.querySelectorAll(".inner-tab");
          tabs.forEach((tab) => {
            tab.addEventListener("click", () => {
              const tabId = tab.dataset.tab;
              const tabGroupId = group.nextElementSibling.id;
              activateInnerTab(tabId, tabGroupId);
            });
          });
        });
      }

      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        sidebar.classList.toggle("active");
      }

      function toggleTheme() {
        // Theme toggling functionality will be implemented later
        alert("Theme toggling will be implemented in a future update");
      }

      function initializeFutureUI() {
        if (!appState.future.loaded) return;

        showFutureStatus(
          "Semantic Embedding Evaluation data loaded successfully. Generating visualizations...",
          "info"
        );

        // Create the visualizations
        createCosineSimilarityPlot();
        createErrorPlot();
        createPCAScatterPlot();
        createOutliersTable();
        populateFutureWordSelect();

        showFutureStatus(
          "Semantic Embedding Evaluation visualizations loaded successfully.",
          "success"
        );
      }

      // Upload Functions
      function uploadWicData() {
        const fileInput = document.getElementById("wic-upload");
        const file = fileInput.files[0];
        if (!file) {
          showUploadStatus(
            "wic-upload-status",
            "Please select a file to upload",
            "error"
          );
          return;
        }

        showUploadStatus(
          "wic-upload-status",
          `Loading file: ${file.name}...`,
          "info"
        );

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const data = JSON.parse(e.target.result);

            // Verify it has the expected structure for WiC data
            if (!data.embedding_visualization || !data.layer_performance) {
              throw new Error(
                "Invalid data format: missing required fields for WiC analysis"
              );
            }

            appState.wic.data = data;
            appState.wic.loaded = true;

            // Initialize WiC UI with loaded data
            initializeWicUI();

            showUploadStatus(
              "wic-upload-status",
              `Data successfully loaded from ${file.name}`,
              "success"
            );
            showWicStatus(
              `WiC analysis data loaded successfully from ${file.name}`,
              "success"
            );
          } catch (error) {
            showUploadStatus(
              "wic-upload-status",
              `Error loading data: ${error.message}`,
              "error"
            );
          }
        };

        reader.onerror = function () {
          showUploadStatus("wic-upload-status", "Error reading file", "error");
        };

        reader.readAsText(file);
      }

      function uploadCrossLingualData() {
        const fileInput = document.getElementById("cross-lingual-upload");
        const file = fileInput.files[0];
        if (!file) {
          showUploadStatus(
            "cross-lingual-upload-status",
            "Please select a file to upload",
            "error"
          );
          return;
        }

        showUploadStatus(
          "cross-lingual-upload-status",
          `Loading file: ${file.name}...`,
          "info"
        );

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const data = JSON.parse(e.target.result);

            // Verify it has the expected structure for cross-lingual data
            if (!data.visualizations || !data.words || !data.similarities) {
              throw new Error(
                "Invalid data format: missing required fields for Cross-Lingual analysis"
              );
            }

            appState.crossLingual.data = data;
            appState.crossLingual.loaded = true;

            // Initialize Cross-Lingual UI with loaded data
            initializeCrossLingualUI();

            showUploadStatus(
              "cross-lingual-upload-status",
              `Data successfully loaded from ${file.name}`,
              "success"
            );
            showCrossLingualStatus(
              `Cross-Lingual analysis data loaded successfully from ${file.name}`,
              "success"
            );
          } catch (error) {
            showUploadStatus(
              "cross-lingual-upload-status",
              `Error loading data: ${error.message}`,
              "error"
            );
          }
        };

        reader.onerror = function () {
          showUploadStatus(
            "cross-lingual-upload-status",
            "Error reading file",
            "error"
          );
        };

        reader.readAsText(file);
      }

      function uploadFutureData() {
        const fileInput = document.getElementById("future-upload");
        const file = fileInput.files[0];
        if (!file) {
          showUploadStatus(
            "future-upload-status",
            "Please select a file to upload",
            "error"
          );
          return;
        }

        showUploadStatus(
          "future-upload-status",
          `Loading file: ${file.name}...`,
          "info"
        );

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const data = JSON.parse(e.target.result);

            // Verify it has the expected structure
            if (
              !data["similarity scores"] ||
              !data.PCA_data ||
              !data.scatter_data
            ) {
              throw new Error(
                "Invalid data format: missing required fields for Semantic Embedding Evaluation analysis"
              );
            }

            appState.future.data = data;
            appState.future.loaded = true;

            // Initialize Future UI with loaded data
            initializeFutureUI();

            showUploadStatus(
              "future-upload-status",
              `Data successfully loaded from ${file.name}`,
              "success"
            );
            showFutureStatus(
              `Semantic Embedding Evaluation data loaded successfully from ${file.name}`,
              "success"
            );
          } catch (error) {
            showUploadStatus(
              "future-upload-status",
              `Error loading data: ${error.message}`,
              "error"
            );
          }
        };

        reader.onerror = function () {
          showUploadStatus(
            "future-upload-status",
            "Error reading file",
            "error"
          );
        };

        reader.readAsText(file);
      }

      function showUploadStatus(elementId, message, type = "info") {
        const statusEl = document.getElementById(elementId);
        statusEl.innerHTML = message;
        statusEl.className = `status-message status-${type}`;
      }

      function showWicStatus(message, type = "info") {
        const statusEl = document.getElementById("wic-status");
        statusEl.innerHTML = message;
        statusEl.className = `status-message status-${type}`;
      }

      function showCrossLingualStatus(message, type = "info") {
        const statusEl = document.getElementById("cross-lingual-status");
        statusEl.innerHTML = message;
        statusEl.className = `status-message status-${type}`;
      }

      // Future

      function showFutureStatus(message, type = "info") {
        const statusEl = document.getElementById("future-status");
        statusEl.innerHTML = message;
        statusEl.className = `status-message status-${type}`;
      }

      // Populate word selection dropdown
      function populateFutureWordSelect() {
        const select = document.getElementById("future-word-select");
        if (!select) return;

        select.innerHTML = '<option value="all">All Words</option>';

        if (!appState.future.data || !appState.future.data.PCA_data) return;

        // Get unique target words
        const points = appState.future.data.PCA_data.points;
        const uniqueWords = [...new Set(points.map((p) => p.Target))];

        uniqueWords.forEach((word) => {
          const option = document.createElement("option");
          option.value = word;
          option.textContent = word;
          select.appendChild(option);
        });
      }

      // Create Cosine Similarity Plot
      function createCosineSimilarityPlot() {
        if (!appState.future.loaded || !appState.future.data.scatter_data)
          return;
        const data = appState.future.data.scatter_data;
        const plotDiv = document.getElementById("cosine-similarity-plot");
        if (!plotDiv) return;

        // Prepare data for plotting
        const bluePoints = data.points.filter((p) => p.Color === "blue");
        const redPoints = data.points.filter((p) => p.Color === "red");

        const traces = [
          {
            x: bluePoints.map((p) => p.X),
            y: bluePoints.map((p) => p.Y),
            mode: "markers",
            type: "scatter",
            name: "Synonyms",
            text: bluePoints.map((p) => p.Hover), // Add hover text
            hoverinfo: "text", // Display the text on hover
            marker: {
              color: "blue",
              size: bluePoints.map((p) => p.Size),
            },
          },
          {
            x: redPoints.map((p) => p.X),
            y: redPoints.map((p) => p.Y),
            mode: "markers",
            type: "scatter",
            name: "Homonyms",
            text: redPoints.map((p) => p.Hover), // Add hover text
            hoverinfo: "text", // Display the text on hover
            marker: {
              color: "red",
              size: redPoints.map((p) => p.Size),
            },
          },
        ];

        const layout = {
          title: data.title || "Cosine Similarity Scatter Plot",
          xaxis: {
            title: "Index",
          },
          yaxis: {
            title: "Cosine Similarity",
            range: [0, 1],
          },
          hovermode: "closest",
          legend: {
            x: 0,
            y: 1,
          },
        };

        Plotly.newPlot(plotDiv, traces, layout);
      }

      // Create Error Plot
      function createErrorPlot() {
        if (
          !appState.future.loaded ||
          !appState.future.data[
            "Realiability of cosine similarity with #common words"
          ]
        )
          return;
        const data =
          appState.future.data[
            "Realiability of cosine similarity with #common words"
          ];
        const plotDiv = document.getElementById("error-plot");
        if (!plotDiv) return;

        // Prepare data for plotting
        const bluePoints = data.points.filter((p) => p.Color === "blue");
        const redPoints = data.points.filter((p) => p.Color === "red");

        const traces = [
          {
            x: bluePoints.map((p) => p.X),
            y: bluePoints.map((p) => p.Y),
            mode: "markers",
            type: "scatter",
            name: "Synonyms",
            text: bluePoints.map((p) => p.Hover), // Add hover text
            hoverinfo: "text", // Display the text on hover
            marker: {
              color: "blue",
              size: bluePoints.map((p) => p.Size || 8),
            },
          },
          {
            x: redPoints.map((p) => p.X),
            y: redPoints.map((p) => p.Y),
            mode: "markers",
            type: "scatter",
            name: "Homonyms",
            text: redPoints.map((p) => p.Hover), // Add hover text
            hoverinfo: "text", // Display the text on hover
            marker: {
              color: "red",
              size: redPoints.map((p) => p.Size || 8),
            },
          },
        ];

        const layout = {
          title: data.title || "Error with Common Words",
          xaxis: {
            title: "Percentage of Common Words",
          },
          yaxis: {
            title: "Error",
            range: [0, 1],
          },
          hovermode: "closest",
          legend: {
            x: 0,
            y: 1,
          },
        };

        Plotly.newPlot(plotDiv, traces, layout);
      }

      // Create PCA Scatter Plot
      function createPCAScatterPlot() {
        if (!appState.future.loaded || !appState.future.data.PCA_data) return;

        const data = appState.future.data.PCA_data;
        const plotDiv = document.getElementById("pca-scatter-plot");
        const wordFilter = document.getElementById("future-word-select");

        if (!plotDiv) return;

        let selectedWord = wordFilter ? wordFilter.value : "all";

        // Filter points if a specific word is selected
        let points = data.points;
        let synonymPoints = [];

        if (selectedWord !== "all") {
          // Find the target points
          points = points.filter((p) => p.Target === selectedWord);

          // Find all synonym words from the selected target points
          const allSynonyms = new Set();
          points.forEach((point) => {
            if (point.Synonyms && Array.isArray(point.Synonyms)) {
              point.Synonyms.forEach((syn) => allSynonyms.add(syn));
            }
          });

          // Find synonym points from all data points
          if (allSynonyms.size > 0) {
            synonymPoints = data.points.filter(
              (p) => allSynonyms.has(p.Word) && p.Target !== selectedWord
            );
          }
        }

        const traces = [];

        // First add the selected word points
        if (points.length > 0) {
          traces.push({
            x: points.map((p) => p.PCA_X || p.tSNE_X),
            y: points.map((p) => p.PCA_Y || p.tSNE_Y),
            mode: "markers+text",
            type: "scatter",
            name: selectedWord !== "all" ? selectedWord : "All Words",
            text: points.map((p) => p.Word),
            textposition: "top center",
            marker: {
              color: "#1f77b4", // Primary color for the selected word
              size: 12,
            },
            hovertemplate:
              "<b>%{text}</b><br>Target: %{customdata.target}" +
              "<br>Sentence: %{customdata.sentence}<extra></extra>",
            customdata: points.map((p) => ({
              target: p.Target,
              sentence: p._Sentence || "",
            })),
          });
        }

        // If "all" is selected, group by target word for coloring
        if (selectedWord === "all") {
          const targets = [...new Set(points.map((p) => p.Target))];
          const colors = [
            "#ff7f0e",
            "#2ca02c",
            "#d62728",
            "#9467bd",
            "#8c564b",
            "#e377c2",
            "#7f7f7f",
            "#bcbd22",
            "#17becf",
          ];

          targets.forEach((target, i) => {
            const targetPoints = points.filter((p) => p.Target === target);

            traces.push({
              x: targetPoints.map((p) => p.PCA_X || p.tSNE_X),
              y: targetPoints.map((p) => p.PCA_Y || p.tSNE_Y),
              mode: "markers+text",
              type: "scatter",
              name: target,
              text: targetPoints.map((p) => p.Word),
              textposition: "top center",
              marker: {
                color: colors[i % colors.length],
                size: 12,
              },
              hovertemplate:
                "<b>%{text}</b><br>Target: %{customdata.target}" +
                "<br>Sentence: %{customdata.sentence}<extra></extra>",
              customdata: targetPoints.map((p) => ({
                target: p.Target,
                sentence: p._Sentence || "",
              })),
            });
          });
        }
        // If a specific word is selected, add the synonyms as separate traces with different colors
        else if (synonymPoints.length > 0) {
          // Group synonyms by their word
          const synonymWords = [...new Set(synonymPoints.map((p) => p.Word))];
          const colors = [
            "#ff7f0e",
            "#2ca02c",
            "#d62728",
            "#9467bd",
            "#8c564b",
            "#e377c2",
            "#7f7f7f",
            "#bcbd22",
            "#17becf",
          ];

          synonymWords.forEach((synonym, i) => {
            const synPoints = synonymPoints.filter((p) => p.Word === synonym);

            traces.push({
              x: synPoints.map((p) => p.PCA_X || p.tSNE_X),
              y: synPoints.map((p) => p.PCA_Y || p.tSNE_Y),
              mode: "markers+text",
              type: "scatter",
              name: `${synonym} (synonym)`,
              text: synPoints.map((p) => p.Word),
              textposition: "top center",
              marker: {
                color: colors[i % colors.length],
                size: 12,
              },
              hovertemplate:
                "<b>%{text}</b><br>Synonym of: " +
                selectedWord +
                "<br>Target: %{customdata.target}" +
                "<br>Sentence: %{customdata.sentence}<extra></extra>",
              customdata: synPoints.map((p) => ({
                target: p.Target,
                sentence: p._Sentence || "",
              })),
            });
          });
        }

        const layout = {
          title:
            selectedWord !== "all"
              ? `PCA of "${selectedWord}" and its synonyms`
              : data.title || "PCA of Word Embeddings",
          xaxis: {
            title: "PC1",
          },
          yaxis: {
            title: "PC2",
          },
          hovermode: "closest",
          legend: {
            x: 0,
            y: 1,
          },
          showlegend: false,
        };

        Plotly.newPlot(plotDiv, traces, layout);
      }

      // Filter PCA by specific word
      function filterPCAByWord() {
        createPCAScatterPlot();
      }

      // Create Outliers Table
      function createOutliersTable() {
        if (!appState.future.loaded || !appState.future.data["Outliers Table"])
          return;

        const data = appState.future.data["Outliers Table"];
        const tableDiv = document.getElementById("outliers-table");

        if (!tableDiv) return;

        // Create synonym outliers table
        let tableHTML = `
    <h3>Synonym Outliers</h3>
    <div class="table-container">
      <table>
        <thead>
          <tr>
            <th>Word 1</th>
            <th>Word 2</th>
            <th>Cosine Similarity</th>
            <th>Sentence 1</th>
            <th>Sentence 2</th>
          </tr>
        </thead>
        <tbody>
  `;

        // Get indices to display (show first 10 or all if less than 10)
        const synKeys = Object.keys(data.Synonyms.Word1);
        const synIndices = synKeys.slice(0, Math.min(10, synKeys.length));

        synIndices.forEach((idx) => {
          tableHTML += `
      <tr>
        <td>${data.Synonyms.Word1[idx]}</td>
        <td>${data.Synonyms.Word2[idx]}</td>
        <td>${parseFloat(data.Synonyms.CoSim[idx]).toFixed(4)}</td>
        <td>${data.Synonyms.Sent1[idx]}</td>
        <td>${data.Synonyms.Sent2[idx]}</td>
      </tr>
    `;
        });

        tableHTML += `
        </tbody>
      </table>
    </div>
    
    <h3>Homonym Outliers</h3>
    <div class="table-container">
      <table>
        <thead>
          <tr>
            <th>Word 1</th>
            <th>Word 2</th>
            <th>Cosine Similarity</th>
            <th>Sentence 1</th>
            <th>Sentence 2</th>
          </tr>
        </thead>
        <tbody>
  `;

        // Get indices for homonyms
        const homKeys = Object.keys(data.Homonyms.Word1);
        const homIndices = homKeys.slice(0, Math.min(10, homKeys.length));

        homIndices.forEach((idx) => {
          tableHTML += `
      <tr>
        <td>${data.Homonyms.Word1[idx]}</td>
        <td>${data.Homonyms.Word2[idx]}</td>
        <td>${parseFloat(data.Homonyms.CoSim[idx]).toFixed(4)}</td>
        <td>${data.Homonyms.Sent1[idx]}</td>
        <td>${data.Homonyms.Sent2[idx]}</td>
      </tr>
    `;
        });

        tableHTML += `
        </tbody>
      </table>
    </div>
  `;

        tableDiv.innerHTML = tableHTML;
      }

      // Create summary stats section
      function createSummaryStats() {
        if (
          !appState.future.loaded ||
          !appState.future.data["similarity scores"]
        )
          return;

        const data = appState.future.data["similarity scores"];
        const statsDiv = document.getElementById("summary-stats");

        if (!statsDiv) return;

        statsDiv.innerHTML = `
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-title">Synonym Avg. Similarity</div>
        <div class="stat-value">${data.synonym.avg.toFixed(4)}</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">Homonym Avg. Similarity</div>
        <div class="stat-value">${data.homonym.avg.toFixed(4)}</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">Synonym Min-Max</div>
        <div class="stat-value">${data.synonym.min.toFixed(
          2
        )}-${data.synonym.max.toFixed(2)}</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">Homonym Min-Max</div>
        <div class="stat-value">${data.homonym.min.toFixed(
          2
        )}-${data.homonym.max.toFixed(2)}</div>
      </div>
    
  `;
      }

      // WiC Visualization Functions
      function initializeWicUI() {
        if (!appState.wic.loaded) return;

        // Populate layer select
        populateWicLayerSelect();

        // Populate word select
        populateWicWordSelect();

        // Update plots
        updateWicPerformancePlot();
        updateWicEmbeddingPlot();

        // Render examples
        renderWicExampleAnalysis();
      }

      function populateWicLayerSelect() {
        const select = document.getElementById("wic-layer-select");
        select.innerHTML = "";

        if (!appState.wic.data || !appState.wic.data.embedding_visualization)
          return;

        const layers = appState.wic.data.embedding_visualization.layers.map(
          (l) => l.layer
        );

        layers.forEach((layer) => {
          const option = document.createElement("option");
          option.value = layer;

          if (layer === 0) {
            option.textContent = `Layer ${layer} (Input)`;
          } else if (layer === Math.max(...layers)) {
            option.textContent = `Layer ${layer} (Final)`;
          } else {
            option.textContent = `Layer ${layer}`;
          }

          select.appendChild(option);
        });

        // Select the last layer by default
        if (layers.length > 0) {
          select.value = Math.max(...layers);
        }
      }

      function populateWicWordSelect() {
        const select = document.getElementById("wic-word-select");
        select.innerHTML = '<option value="all">All Words</option>';

        if (!appState.wic.data || !appState.wic.data.target_words) return;

        const words = appState.wic.data.target_words;

        words.forEach((word) => {
          const option = document.createElement("option");
          option.value = word;
          option.textContent = word;
          select.appendChild(option);
        });
      }

      function updateWicPerformancePlot() {
        if (!appState.wic.loaded || !appState.wic.data.layer_performance) {
          return;
        }

        showWicLoading(true, "performance");

        const metric = document.getElementById("wic-metric-select").value;
        const method = document.getElementById("wic-method-select").value;

        const plotData = [];

        // Add metric line
        const perfData = appState.wic.data.layer_performance[method];
        if (perfData && perfData[metric]) {
          plotData.push({
            x: perfData.layers,
            y: perfData[metric],
            mode: "lines+markers",
            name: metric.charAt(0).toUpperCase() + metric.slice(1),
            line: {
              color: "#3a6ea5",
              width: 2,
            },
            marker: {
              size: 8,
              color: "#3a6ea5",
            },
          });
        }

        const layout = {
          title: `${
            method === "cosine" ? "Cosine Similarity" : "Logistic Regression"
          } Performance`,
          xaxis: {
            title: "BERT Layer",
            tickmode: "array",
            tickvals: perfData ? perfData.layers : [],
          },
          yaxis: {
            title: metric.charAt(0).toUpperCase() + metric.slice(1),
            range: [0.5, 1],
          },
          margin: {
            l: 50,
            r: 20,
            t: 50,
            b: 50,
          },
          hovermode: "closest",
        };

        Plotly.newPlot("wic-performance-plot", plotData, layout);
        showWicLoading(false, "performance");
      }

      function updateWicEmbeddingPlot() {
        if (
          !appState.wic.loaded ||
          !appState.wic.data.embedding_visualization
        ) {
          return;
        }

        showWicLoading(true, "embedding");

        const layerValue = document.getElementById("wic-layer-select").value;
        const wordValue = document.getElementById("wic-word-select").value;

        // Find the selected layer data
        const layerData = appState.wic.data.embedding_visualization.layers.find(
          (l) => l.layer == layerValue
        );

        if (!layerData) {
          console.error(`Layer ${layerValue} not found in data`);
          showWicLoading(false, "embedding");
          return;
        }

        const plotData = [];

        // Filter points by selected word if specified
        const points =
          wordValue === "all"
            ? layerData.points
            : layerData.points.filter((p) => p.target_word === wordValue);

        // Create colors mapping for target words
        const uniqueWords = [...new Set(points.map((p) => p.target_word))];
        const colors = [
          "#1f77b4",
          "#ff7f0e",
          "#2ca02c",
          "#d62728",
          "#9467bd",
          "#8c564b",
          "#e377c2",
          "#7f7f7f",
          "#bcbd22",
          "#17becf",
        ];
        const wordColors = {};
        uniqueWords.forEach((word, i) => {
          wordColors[word] = colors[i % colors.length];
        });

        // Add connecting lines between contexts
        points.forEach((point) => {
          const color =
            point.label === "same" ? "rgba(0,128,0,0.3)" : "rgba(255,0,0,0.3)";

          plotData.push({
            x: [point.coordinates[0].x, point.coordinates[1].x],
            y: [point.coordinates[0].y, point.coordinates[1].y],
            mode: "lines",
            line: {
              color: color,
              width: 1,
            },
            showlegend: false,
            hoverinfo: "none",
          });
        });

        // Add points for each context
        points.forEach((point) => {
          const word = point.target_word;
          const color = wordColors[word];

          // Context 1
          plotData.push({
            x: [point.coordinates[0].x],
            y: [point.coordinates[0].y],
            mode: "markers+text",
            type: "scatter",
            marker: {
              color: color,
              size: 10,
              line: {
                color: "white",
                width: 1,
              },
            },
            text: [word],
            textposition: "top center",
            name: `${word} (Context 1)`,
            hovertext: `${word}: ${point.context1.substring(0, 40)}...`,
            showlegend: wordValue === "all",
          });

          // Context 2
          plotData.push({
            x: [point.coordinates[1].x],
            y: [point.coordinates[1].y],
            mode: "markers+text",
            type: "scatter",
            marker: {
              color: color,
              size: 10,
              symbol: "square",
              line: {
                color: "white",
                width: 1,
              },
            },
            text: [word],
            textposition: "top center",
            name: `${word} (Context 2)`,
            hovertext: `${word}: ${point.context2.substring(0, 40)}...`,
            showlegend: wordValue === "all",
          });
        });

        const layout = {
          title: `Layer ${layerValue} Word Embeddings (t-SNE)`,
          xaxis: {
            title: "Dimension 1",
            zeroline: false,
            showticklabels: false,
          },
          yaxis: {
            title: "Dimension 2",
            zeroline: false,
            showticklabels: false,
            scaleanchor: "x",
          },
          margin: {
            l: 40,
            r: 20,
            t: 50,
            b: 40,
          },
          legend: {
            itemsizing: "constant",
            itemwidth: 30,
          },
          hovermode: "closest",
          annotations: [
            {
              x: 0.5,
              y: -0.15,
              xref: "paper",
              yref: "paper",
              text: "Red lines = Different meanings, Green lines = Same meaning",
              showarrow: false,
              font: {
                size: 10,
              },
            },
          ],
        };

        Plotly.newPlot("wic-embedding-plot", plotData, layout);
        showWicLoading(false, "embedding");
      }

      function renderWicExampleAnalysis() {
        if (!appState.wic.loaded || !appState.wic.data.example_analysis) {
          return;
        }

        const examples = appState.wic.data.example_analysis;

        // Render improved examples
        renderWicExamples("improved", examples.improved || []);

        // Render worsened examples
        renderWicExamples("worsened", examples.worsened || []);
      }

      function renderWicExamples(type, examples) {
        const container = document.getElementById(`wic-${type}-examples`);
        container.innerHTML = "";

        if (examples.length === 0) {
          container.innerHTML = `<p>No ${type} examples available</p>`;
          return;
        }

        examples.forEach((ex) => {
          const exampleEl = document.createElement("div");
          exampleEl.className = "example-item";

          const header = document.createElement("div");
          header.className = "example-header";
          header.innerHTML = `
            <div>Word: <span class="highlight">${ex.target_word}</span></div>
            <div>Label: <span class="highlight">${ex.label}</span></div>
          `;

          const contexts = document.createElement("div");
          contexts.className = "example-contexts";

          const context1 = document.createElement("div");
          context1.className = "context";
          context1.innerHTML = ex.context1;

          const context2 = document.createElement("div");
          context2.className = "context";
          context2.innerHTML = ex.context2;

          contexts.appendChild(context1);
          contexts.appendChild(context2);

          const similarities = document.createElement("div");
          similarities.innerHTML = `
            <div class="similarity-bar">
              <div class="bar-label">Layer ${ex.best_layer} Similarity:</div>
              <div class="bar" style="width: ${ex.best_sim * 100}px;"></div>
              <div style="margin-left: 8px;">${ex.best_sim.toFixed(2)}</div>
            </div>
            <div class="similarity-bar">
              <div class="bar-label">Layer ${ex.worst_layer} Similarity:</div>
              <div class="bar" style="width: ${ex.worst_sim * 100}px;"></div>
              <div style="margin-left: 8px;">${ex.worst_sim.toFixed(2)}</div>
            </div>
          `;

          exampleEl.appendChild(header);
          exampleEl.appendChild(contexts);
          exampleEl.appendChild(similarities);

          container.appendChild(exampleEl);
        });
      }

      function showWicLoading(show, type) {
        document.getElementById(`wic-${type}-loading`).style.display = show
          ? "flex"
          : "none";
      }

      // Cross-Lingual Visualization Functions
      function initializeCrossLingualUI() {
        if (!appState.crossLingual.loaded) return;

        // Populate dropdowns
        populateClDropdowns();

        // Display visualizations
        displayClOverallStats();
        displayClCategoryStats();
        // createClCategorySimilarityChart();
        createClPCAScatterPlot();
        // createClSimilarityHeatmap();
        displayClWordPairsTable();
      }

      function populateClDropdowns() {
        const data = appState.crossLingual.data;
        if (!data) return;

        // Populate word pair dropdown
        const pairSelect = document.getElementById("cl-pair-select");
        pairSelect.innerHTML = '<option value="all">All Pairs</option>';

        data.words.forEach((pair, index) => {
          const option = document.createElement("option");
          option.value = index;
          option.textContent = `${pair.english} / ${pair.spanish}`;
          pairSelect.appendChild(option);
        });

        // Populate category dropdown
        const categorySelect = document.getElementById("cl-category-select");
        categorySelect.innerHTML =
          '<option value="all">All Categories</option>';

        const uniqueCategories = [...new Set(data.categories)];
        uniqueCategories.forEach((category) => {
          const option = document.createElement("option");
          option.value = category;
          option.textContent = formatClCategoryName(category);
          categorySelect.appendChild(option);
        });
      }

      function handleClPairChange() {
        const selectedValue = document.getElementById("cl-pair-select").value;

        if (!appState.crossLingual.loaded) return;

        if (selectedValue === "all") {
          // Show all pairs
          document.getElementById("cl-pair-detail").style.display = "none";

          // Redraw PCA with all points
          createClPCAScatterPlot();
        } else {
          // Show selected pair details
          const selectedIndex = parseInt(selectedValue);
          showClPairDetails(selectedIndex);

          // Highlight the selected pair in the PCA plot
          highlightClPairInPCA(selectedIndex);
        }
      }

      function handleClCategoryChange() {
        const selectedCategory =
          document.getElementById("cl-category-select").value;

        if (!appState.crossLingual.loaded) return;

        // Filter PCA by category
        filterClPCAByCategory(selectedCategory);

        // Reset pair selection if filtering by category
        if (selectedCategory !== "all") {
          document.getElementById("cl-pair-select").value = "all";
          document.getElementById("cl-pair-detail").style.display = "none";
        }
      }

      function showClPairDetails(index) {
        if (!appState.crossLingual.loaded) return;

        const data = appState.crossLingual.data;
        const pairDetail = document.getElementById("cl-pair-detail");
        pairDetail.style.display = "block";

        const wordPair = data.words[index];
        const similarity = data.similarities[index];
        const category = data.categories[index];

        // Update details
        document.getElementById("cl-english-word").textContent =
          wordPair.english;
        document.getElementById("cl-english-context").textContent =
          wordPair.english_context;
        document.getElementById("cl-spanish-word").textContent =
          wordPair.spanish;
        document.getElementById("cl-spanish-context").textContent =
          wordPair.spanish_context;
        document.getElementById("cl-similarity-value").textContent =
          similarity.toFixed(4);
        document.getElementById("cl-pair-category").textContent =
          formatClCategoryName(category);

        // Scroll to details
        pairDetail.scrollIntoView({ behavior: "smooth" });
      }

      function highlightClPairInPCA(index) {
        if (!appState.crossLingual.loaded) return;

        // Get the PCA data
        const pcaData = appState.crossLingual.data.visualizations.pca_scatter;

        // Create a filtered version highlighting only the selected pair
        const highlightedTraces = [];

        // Add background traces with reduced opacity
        pcaData.data.forEach((trace) => {
          const backgroundTrace = JSON.parse(JSON.stringify(trace));
          backgroundTrace.marker.opacity = 0.2;
          backgroundTrace.textfont = { color: "rgba(0,0,0,0.2)" };
          highlightedTraces.push(backgroundTrace);
        });

        // Add highlighted English point
        highlightedTraces.push({
          x: [pcaData.data[0].x[index]],
          y: [pcaData.data[0].y[index]],
          mode: "markers+text",
          marker: {
            size: 15,
            color: "rgba(31, 119, 180, 1)",
            line: {
              width: 2,
              color: "black",
            },
          },
          text: [pcaData.data[0].text[index]],
          name: "Selected English",
          textposition: "top center",
        });

        // Add highlighted Spanish point
        highlightedTraces.push({
          x: [pcaData.data[1].x[index]],
          y: [pcaData.data[1].y[index]],
          mode: "markers+text",
          marker: {
            size: 15,
            color: "rgba(255, 127, 14, 1)",
            symbol: "square",
            line: {
              width: 2,
              color: "black",
            },
          },
          text: [pcaData.data[1].text[index]],
          name: "Selected Spanish",
          textposition: "bottom center",
        });

        // Add connection line
        highlightedTraces.push({
          x: [pcaData.data[0].x[index], pcaData.data[1].x[index]],
          y: [pcaData.data[0].y[index], pcaData.data[1].y[index]],
          mode: "lines",
          line: {
            color: "rgba(0, 0, 0, 1)",
            width: 3,
            dash: "dot",
          },
          showlegend: false,
        });

        // Update the plot
        const layout = {
          title: "PCA Visualization of Word Embeddings (Highlighted Pair)",
          xaxis: {
            title: "PC1",
          },
          yaxis: {
            title: "PC2",
          },
          hovermode: "closest",
          legend: {
            orientation: "h",
            yanchor: "bottom",
            y: -0.2,
          },
        };

        Plotly.newPlot("cl-pca-scatter-plot", highlightedTraces, layout);
      }

      function filterClPCAByCategory(category) {
        if (!appState.crossLingual.loaded) return;

        if (category === "all") {
          // Show all categories
          createClPCAScatterPlot();
          return;
        }

        const data = appState.crossLingual.data;

        // Get indices of pairs in the selected category
        const indices = data.categories
          .map((cat, idx) => (cat === category ? idx : -1))
          .filter((idx) => idx !== -1);

        // Filter traces to only show this category
        const pcaData = data.visualizations.pca_scatter;
        const filteredTraces = [];

        // English points
        filteredTraces.push({
          x: indices.map((idx) => pcaData.data[0].x[idx]),
          y: indices.map((idx) => pcaData.data[0].y[idx]),
          mode: "markers+text",
          marker: {
            size: 12,
            color: getClColorForCategory(category),
          },
          text: indices.map((idx) => pcaData.data[0].text[idx]),
          name: "English",
          textposition: "top center",
        });

        // Spanish points
        filteredTraces.push({
          x: indices.map((idx) => pcaData.data[1].x[idx]),
          y: indices.map((idx) => pcaData.data[1].y[idx]),
          mode: "markers+text",
          marker: {
            size: 12,
            color: getClColorForCategory(category),
            symbol: "square",
          },
          text: indices.map((idx) => pcaData.data[1].text[idx]),
          name: "Spanish",
          textposition: "bottom center",
        });

        // Connection lines
        for (let i = 0; i < indices.length; i++) {
          const idx = indices[i];
          filteredTraces.push({
            x: [pcaData.data[0].x[idx], pcaData.data[1].x[idx]],
            y: [pcaData.data[0].y[idx], pcaData.data[1].y[idx]],
            mode: "lines",
            line: {
              color: getClColorForCategory(category),
              width: 1,
            },
            showlegend: false,
            hoverinfo: "none",
          });
        }

        // Update the plot
        const layout = {
          title: `PCA Visualization - Category: ${formatClCategoryName(
            category
          )}`,
          xaxis: {
            title: "PC1",
          },
          yaxis: {
            title: "PC2",
          },
          hovermode: "closest",
          legend: {
            orientation: "h",
            yanchor: "bottom",
            y: -0.2,
          },
        };

        Plotly.newPlot("cl-pca-scatter-plot", filteredTraces, layout);
      }

      function displayClOverallStats() {
        if (!appState.crossLingual.loaded) return;

        const stats = appState.crossLingual.data.overall_stats;
        if (!stats) {
          document.getElementById("cl-overall-stats").innerHTML =
            '<div class="error-message">No overall statistics available</div>';
          return;
        }

        const statsDiv = document.getElementById("cl-overall-stats");

        // Create a more visually appealing stats display
        statsDiv.innerHTML = `
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-title">Synonyms Mean Similarity</div>
              <div class="stat-value">${stats.mean_similarity_syn.toFixed(
                4
              )}</div>
            </div>
            <div class="stat-card">
              <div class="stat-title">Homonyms Mean Similarity</div>
              <div class="stat-value">${stats.mean_similarity_hom.toFixed(
                4
              )}</div>
            </div>
            <div class="stat-card">
              <div class="stat-title">Synonyms Standard deviation</div>
              <div class="stat-value">0.0552</div>
            </div>
            <div class="stat-card">
              <div class="stat-title">Homonyms Standard deviation</div>
              <div class="stat-value">0.1001</div>
            </div>
          </div>
        `;
      }

      function displayClCategoryStats() {
        if (!appState.crossLingual.loaded) return;

        const stats = appState.crossLingual.data.category_stats;
        if (!stats) {
          document.getElementById("cl-category-stats").innerHTML =
            '<div class="error-message">No category statistics available</div>';
          return;
        }

        const statsDiv = document.getElementById("cl-category-stats");

        // Sort categories by mean similarity (descending)
        const sortedCategories = Object.entries(stats).sort(
          (a, b) => b[1].mean_similarity - a[1].mean_similarity
        );

        let tableHTML = `
          <table>
            <thead>
              <tr>
                <th>Category</th>
                <th>Mean Similarity</th>
                <th>Standard Deviation</th>
                <th>Count</th>
              </tr>
            </thead>
            <tbody>
        `;

        for (const [category, categoryStats] of sortedCategories) {
          // Add color gradient background based on similarity
          const similarity = categoryStats.mean_similarity;
          const bgColor = `rgba(33, ${Math.floor(
            100 + similarity * 155
          )}, ${Math.floor(200 + similarity * 55)}, 0.1)`;

          tableHTML += `
            <tr style="background-color: ${bgColor}">
              <td><strong>${formatClCategoryName(category)}</strong></td>
              <td>${categoryStats.mean_similarity.toFixed(4)}</td>
              <td>${categoryStats.std_similarity.toFixed(4)}</td>
              <td>${categoryStats.count}</td>
            </tr>
          `;
        }

        tableHTML += `
            </tbody>
          </table>
        `;

        statsDiv.innerHTML = tableHTML;
      }

      function createClCategorySimilarityChart() {
        if (!appState.crossLingual.loaded) return;

        const data =
          appState.crossLingual.data.visualizations.category_similarity_bar;
        if (!data || !data.x || !data.y || !data.error_y) {
          console.error("Invalid category similarity data format");
          document.getElementById("cl-category-similarity-chart").innerHTML =
            '<div style="padding: 20px; text-align: center;">Error loading category data. Please check the data format.</div>';
          return;
        }

        // Sort categories by similarity (descending)
        const sortedData = {
          x: [...data.x],
          y: [...data.y],
          error_y: [...data.error_y],
        };

        const indices = sortedData.y.map((_, idx) => idx);
        indices.sort((a, b) => sortedData.y[b] - sortedData.y[a]);

        sortedData.x = indices.map((i) => formatClCategoryName(data.x[i]));
        sortedData.y = indices.map((i) => data.y[i]);
        sortedData.error_y = indices.map((i) => data.error_y[i]);

        // Add count of word pairs if available
        const customdata = [];
        if (appState.crossLingual.data.category_stats) {
          for (const i of indices) {
            const category = data.x[i];
            const count =
              appState.crossLingual.data.category_stats[category]?.count ||
              "N/A";
            customdata.push(count);
          }
        }

        const trace = {
          x: sortedData.x,
          y: sortedData.y,
          type: "bar",
          marker: {
            color: sortedData.y.map((y) => {
              // Enhanced color gradient based on similarity value
              return `rgba(33, ${Math.floor(100 + y * 155)}, ${Math.floor(
                200 + y * 55
              )}, 0.8)`;
            }),
            line: {
              color: "rgba(25, 25, 25, 0.3)",
              width: 1,
            },
          },
          error_y: {
            type: "data",
            array: sortedData.error_y,
            visible: true,
            color: "#444",
            thickness: 1.5,
            width: 4,
          },
          customdata: customdata,
          hovertemplate:
            "<b>%{x}</b><br>Similarity: %{y:.4f}<br>Standard Dev: %{error_y.array:.4f}<br>Word Pairs: %{customdata}<extra></extra>",
        };

        const layout = {
          title: {
            text: "Mean Similarity by Category",
            font: {
              size: 18,
            },
          },
          xaxis: {
            title: "Category",
            tickangle: -45,
            automargin: true,
          },
          yaxis: {
            title: "Cosine Similarity",
            range: [0, 1],
            tickformat: ".2f",
          },
          margin: {
            b: 150,
            t: 50,
            l: 60,
            r: 30,
          },
          plot_bgcolor: "#fafafa",
          bargap: 0.3,
          autosize: true,
        };

        Plotly.newPlot("cl-category-similarity-chart", [trace], layout, {
          responsive: true,
        });
      }

      function createClPCAScatterPlot() {
        if (!appState.crossLingual.loaded) return;

        const data = appState.crossLingual.data.visualizations.pca_scatter;
        if (!data || !data.data || !data.data[0] || !data.data[1]) {
          console.error("Invalid PCA data format");
          document.getElementById("cl-pca-scatter-plot").innerHTML =
            '<div style="padding: 20px; text-align: center;">Error loading PCA data. Please check the data format.</div>';
          return;
        }

        const traces = data.data;

        // Calculate plot bounds to ensure proper scaling
        let allX = [...traces[0].x, ...traces[1].x];
        let allY = [...traces[0].y, ...traces[1].y];

        let xMin = Math.min(...allX);
        let xMax = Math.max(...allX);
        let yMin = Math.min(...allY);
        let yMax = Math.max(...allY);

        // Add some padding to bounds
        const xPad = (xMax - xMin) * 0.15;
        const yPad = (yMax - yMin) * 0.15;
        xMin -= xPad;
        xMax += xPad;
        yMin -= yPad;
        yMax += yPad;

        // Add lines connecting corresponding word pairs
        const lines = [];
        for (let i = 0; i < traces[0].x.length; i++) {
          lines.push({
            x: [traces[0].x[i], traces[1].x[i]],
            y: [traces[0].y[i], traces[1].y[i]],
            mode: "lines",
            line: {
              color: getClColorForCategory(data.categories[i]),
              width: 1.5,
              opacity: 0.7,
            },
            showlegend: false,
            hoverinfo: "none",
          });
        }

        // Create colored scatter plots for each category
        const categories = [...new Set(data.categories)];
        const categoryTraces = [];

        for (const category of categories) {
          const enIndices = data.categories
            .map((cat, idx) => (cat === category ? idx : -1))
            .filter((idx) => idx !== -1);
          const esIndices = enIndices;

          // Get similarity information for hover
          const similarityInfo = enIndices.map((idx) => {
            if (appState.crossLingual.data.similarities) {
              return appState.crossLingual.data.similarities[idx].toFixed(4);
            }
            return "N/A";
          });

          categoryTraces.push({
            x: enIndices.map((idx) => traces[0].x[idx]),
            y: enIndices.map((idx) => traces[0].y[idx]),
            mode: "markers+text",
            marker: {
              size: 12,
              color: getClColorForCategory(category),
              line: {
                color: "white",
                width: 1,
              },
            },
            text: enIndices.map((idx) => traces[0].text[idx]),
            name: `English (${formatClCategoryName(category)})`,
            textposition: "top center",
            textfont: {
              size: 11,
            },
            hovertemplate:
              "<b>%{text}</b><br>Category: " +
              formatClCategoryName(category) +
              "<br>Similarity: %{customdata}<extra></extra>",
            customdata: similarityInfo,
          });

          categoryTraces.push({
            x: esIndices.map((idx) => traces[1].x[idx]),
            y: esIndices.map((idx) => traces[1].y[idx]),
            mode: "markers+text",
            marker: {
              size: 12,
              color: getClColorForCategory(category),
              symbol: "square",
              line: {
                color: "white",
                width: 1,
              },
            },
            text: esIndices.map((idx) => traces[1].text[idx]),
            name: `Spanish (${formatClCategoryName(category)})`,
            textposition: "bottom center",
            textfont: {
              size: 11,
            },
            hovertemplate:
              "<b>%{text}</b><br>Category: " +
              formatClCategoryName(category) +
              "<br>Similarity: %{customdata}<extra></extra>",
            customdata: similarityInfo,
          });
        }

        const layout = {
          title: {
            text: "PCA Visualization of Multilingual BERT Word Embeddings",
            font: {
              size: 20,
            },
          },
          xaxis: {
            title: "Principal Component 1",
            zeroline: true,
            zerolinecolor: "#aaa",
            gridcolor: "#eee",
            range: [xMin, xMax],
          },
          yaxis: {
            title: "Principal Component 2",
            zeroline: true,
            zerolinecolor: "#aaa",
            gridcolor: "#eee",
            range: [yMin, yMax],
          },
          hovermode: "closest",
          legend: {
            orientation: "h",
            yanchor: "bottom",
            y: -0.2,
            xanchor: "center",
            x: 0.5,
            font: {
              size: 11,
            },
            itemsizing: "constant",
          },
          margin: {
            l: 60,
            r: 50,
            t: 50,
            b: 150,
          },
          plot_bgcolor: "#fafafa",
          annotations: [
            {
              x: 0,
              y: 0,
              xref: "paper",
              yref: "paper",
              text: "Connected lines show corresponding word pairs<br> = English,  = Spanish",
              showarrow: false,
              font: {
                size: 12,
                color: "#666",
              },
              xanchor: "left",
              yanchor: "bottom",
              x: 0.01,
              y: 0.01,
              bgcolor: "rgba(255,255,255,0.7)",
              borderpad: 4,
            },
          ],
          autosize: true,
        };

        Plotly.newPlot(
          "cl-pca-scatter-plot",
          [...lines, ...categoryTraces],
          layout,
          { responsive: true }
        );

        // Add click event to highlight pairs
        const pcaPlot = document.getElementById("cl-pca-scatter-plot");
        pcaPlot.on("plotly_click", function (data) {
          const pointIndex = data.points[0].pointIndex;
          const curveNumber = data.points[0].curveNumber;

          // Get the pair index
          let pairIndex;
          if (curveNumber >= lines.length) {
            // We clicked on a point from categoryTraces
            const categoryIndex = Math.floor((curveNumber - lines.length) / 2);
            const isEnglish = (curveNumber - lines.length) % 2 === 0;

            const category = categories[categoryIndex];
            const indices = appState.crossLingual.data.categories
              .map((cat, idx) => (cat === category ? idx : -1))
              .filter((idx) => idx !== -1);
            pairIndex = indices[pointIndex];
          } else {
            // We clicked on a line, do nothing
            return;
          }

          // Update the dropdown and show details
          document.getElementById("cl-pair-select").value = pairIndex;
          showClPairDetails(pairIndex);
          highlightClPairInPCA(pairIndex);
        });
      }

      function createClSimilarityHeatmap() {
        if (!appState.crossLingual.loaded) return;

        const data =
          appState.crossLingual.data.visualizations.similarity_heatmap;
        if (!data || !data.z || !data.x) {
          console.error("Invalid heatmap data format");
          document.getElementById("cl-similarity-heatmap").innerHTML =
            '<div style="padding: 20px; text-align: center;">Error loading heatmap data. Please check the data format.</div>';
          return;
        }

        // Sort by similarity value
        const sortedIndices = Array.from(Array(data.z.length).keys()).sort(
          (a, b) => data.z[b] - data.z[a]
        );

        const sortedZ = sortedIndices.map((i) => data.z[i]);

        // Shorten x labels to prevent overlap
        const sortedX = sortedIndices.map((i) => {
          const label = data.x[i];
          // Extract just the words for display
          if (label.includes("/")) {
            const [en, es] = label.split("/");
            return `${en.trim()}/${es.trim()}`;
          }
          return label;
        });

        // Get category information for hover if available
        const hoverCategories = [];
        if (appState.crossLingual.data.categories) {
          for (const idx of sortedIndices) {
            const pairIndex = appState.crossLingual.data.words.findIndex(
              (pair, i) => `${pair.english}/${pair.spanish}` === data.x[idx]
            );

            if (pairIndex !== -1) {
              hoverCategories.push(
                formatClCategoryName(
                  appState.crossLingual.data.categories[pairIndex]
                )
              );
            } else {
              hoverCategories.push("Unknown");
            }
          }
        }

        const trace = {
          z: [sortedZ],
          x: sortedX,
          y: ["Similarity"],
          type: "heatmap",
          colorscale: [
            [0, "rgb(247, 251, 255)"], // Very light blue
            [0.3, "rgb(198, 219, 239)"], // Light blue
            [0.6, "rgb(107, 174, 214)"], // Medium blue
            [0.8, "rgb(33, 113, 181)"], // Darker blue
            [1, "rgb(8, 48, 107)"], // Deep blue
          ],
          colorbar: {
            title: {
              text: "Similarity",
              side: "right",
            },
            thickness: 15,
            len: 0.9,
            tickformat: ".2f",
          },
          hovertemplate:
            "<b>%{x}</b><br>Similarity: %{z:.4f}" +
            (hoverCategories.length ? "<br>Category: %{customdata}" : "") +
            "<extra></extra>",
          customdata: hoverCategories,
        };

        const layout = {
          title: {
            text: "Word Pair Similarities (Sorted by Value)",
            font: {
              size: 18,
            },
          },
          xaxis: {
            title: "Word Pairs (English/Spanish)",
            tickangle: -45,
            automargin: true,
            tickfont: {
              size: 10,
            },
          },
          margin: {
            b: 150,
            t: 50,
            l: 60,
            r: 80,
          },
          autosize: true,
        };

        Plotly.newPlot("cl-similarity-heatmap", [trace], layout, {
          responsive: true,
        });

        // Add click event to select pair
        const heatmapPlot = document.getElementById("cl-similarity-heatmap");
        heatmapPlot.on("plotly_click", function (data) {
          const pairLabel = data.points[0].x;
          const pairIndex = appState.crossLingual.data.words.findIndex(
            (pair, idx) => `${pair.english}/${pair.spanish}` === pairLabel
          );

          if (pairIndex !== -1) {
            document.getElementById("cl-pair-select").value = pairIndex;
            showClPairDetails(pairIndex);
            highlightClPairInPCA(pairIndex);
          }
        });
      }

      function displayClWordPairsTable() {
        if (!appState.crossLingual.loaded) return;

        const data = appState.crossLingual.data;
        const tableDiv = document.getElementById("cl-word-pairs-table");
        let tableHTML = `
          <table>
            <tr>
              <th>English Word</th>
              <th>Spanish Word</th>
              <th>English Context</th>
              <th>Spanish Context</th>
              <th>Category</th>
              <th>Similarity</th>
            </tr>
        `;

        // Sort by similarity (descending)
        const indices = Array.from(Array(data.similarities.length).keys()).sort(
          (a, b) => data.similarities[b] - data.similarities[a]
        );

        for (const idx of indices) {
          tableHTML += `
            <tr data-index="${idx}" class="cl-pair-row">
              <td>${data.words[idx].english}</td>
              <td>${data.words[idx].spanish}</td>
              <td>${data.words[idx].english_context}</td>
              <td>${data.words[idx].spanish_context}</td>
              <td>${formatClCategoryName(data.categories[idx])}</td>
              <td>${data.similarities[idx].toFixed(4)}</td>
            </tr>
          `;
        }

        tableHTML += "</table>";
        tableDiv.innerHTML = tableHTML;

        // Add click event to rows
        setTimeout(() => {
          const rows = document.querySelectorAll(".cl-pair-row");
          rows.forEach((row) => {
            row.addEventListener("click", function () {
              const pairIndex = parseInt(this.getAttribute("data-index"));
              document.getElementById("cl-pair-select").value = pairIndex;
              showClPairDetails(pairIndex);
              highlightClPairInPCA(pairIndex);
            });
          });
        }, 100);
      }

      // Helper Functions
      function formatClCategoryName(category) {
        // Convert "homonym_financial" to "Homonym: Financial"
        return category
          .replace("_", ": ")
          .split(" ")
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(" ");
      }

      function getClColorForCategory(category) {
        const colors = {
          synonym: "rgb(31, 119, 180)",
          homonym_financial: "rgb(255, 127, 14)",
          homonym_riverside: "rgb(214, 39, 40)",
          homonym_illumination: "rgb(44, 160, 44)",
          homonym_weight: "rgb(148, 103, 189)",
          homonym_season: "rgb(140, 86, 75)",
          homonym_coil: "rgb(227, 119, 194)",
          homonym_animal: "rgb(127, 127, 127)",
          homonym_sports: "rgb(188, 189, 34)",
          homonym_reading: "rgb(23, 190, 207)",
          homonym_reserve: "rgb(174, 199, 232)",
        };

        return colors[category] || "rgb(0, 0, 0)";
      }

      document.addEventListener("DOMContentLoaded", function () {
        // Add event listener for future word select if it doesn't exist already
        const futureWordSelect = document.getElementById("future-word-select");
        if (futureWordSelect) {
          futureWordSelect.addEventListener("change", filterPCAByWord);
        }

        // Initialize future module if data is already loaded
        if (appState.future.loaded) {
          initializeFutureUI();
        }
      });

      // Update the uploadFutureData function to actually process the data
      // (Replace the existing uploadFutureData function with the one from nlp-visualization-updates)

      // Update the toggleSidebar function to handle future module activation
      const originalActivateTab = activateTab;
      activateTab = function (tabId) {
        originalActivateTab(tabId);

        // Check if we're activating the future module and it's loaded
        if (tabId === "future" && appState.future.loaded) {
          // Refresh visualizations on tab activation
          createCosineSimilarityPlot();
          createErrorPlot();
          createPCAScatterPlot();
          createSummaryStats();

          // Make sure charts are properly sized
          window.dispatchEvent(new Event("resize"));
        }
      };

      // Add to the initialization functions to ensure the future module is included
      function initializeAllTabs() {
        if (appState.wic.loaded) {
          initializeWicUI();
        }
        if (appState.crossLingual.loaded) {
          initializeCrossLingualUI();
        }
        if (appState.future.loaded) {
          initializeFutureUI();
        }
      }

      // Call this on initial page load
      setTimeout(initializeAllTabs, 500);
    </script>
  </body>
</html>
